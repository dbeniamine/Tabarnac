Numalize plot visualization
===========================


**TODO: Differentiate Others: stack / Others : var**

```{r Parsing, echo=F}
#Parse csv files
require(methods, quiet=T)
library(ggplot2)
library(plyr)
library(stringr)
library(data.table)
# The palette with grey:
base=paste(path,"/",name, sep="")
structs<-data.frame(read.csv2(file=paste(base,".structs.csv",sep=""),sep=',',dec='.',stringsAsFactors=FALSE))
acc<-data.frame(read.csv2(file=paste(base,".full.page.csv",sep=""),sep=',',dec='.',stringsAsFactors=FALSE))
# Information not neequired
acc$firstacc <- NULL
# Merge duplicate addresses
acct <- data.table(acc)
acct <- acct[,lapply(.SD,sum),by=c("addr","type")]
acc <- data.frame(acct)
acc$total  <- rowSums(acc[,-1:-3])
stacks<-data.frame(read.csv2(file=paste(base,".stackmap.csv",sep=""),sep=',',dec='.',stringsAsFactors=FALSE))
```
```{r StructSizes, echo=F}
p <- ggplot(structs, aes(x=name,y=sz, fill=name))
p <- p + geom_bar(stat="identity")
p <- p + ggtitle(paste("Structures size for", name)) + xlab("Structure name") + ylab("Size (bytes)")
p <- p + theme(legend.position="none")
if(bw)
{
p <- p + theme_bw()
p <- p + scale_fill_grey()
}
structs$end <- rowSums(structs[,2:3])
structs$sz <- NULL
structs <- rbind(structs,c("Others",0,0,0))
```
```{r RetrievingPageStructMapping, echo=F}
# Retrieve page / structure mapping
snames=c()
structs <- transform(structs, start=as.numeric(as.character(start)),end=as.numeric(as.character(end)))
structs <- structs[order(structs$start),]
# Here we know that structs and acc are sorted by adresse, which ease the search
i <- 2
cur <- 2
cpt <- 1
for(page in unique(acc$addr))
{
    addr <- (2^12)*page
    OK <- F
    cur <- 1
    while(!OK && i<=nrow(structs))
    {
        #show(paste(cpt,"loop current struct", i, "addr", addr))
        if(addr < structs[i,]$start)
        {
            #Addr is between two structs
            OK <- T
            #show(paste(cpt,addr,"between structs nÂ°",i-1,i))
        }else
        {
            if(addr >= structs[i,]$start && addr < structs[i,]$end)
            {
                # Addr is in the next struct
                #show(paste(cpt,addr,"in struct", structs[i,]$name))
                OK <- T
                cur <- i
            }else
            {
                #Addr might be in the next struct
                i <- i+1
            }
        }
    }
    snames <- c(snames,structs$name[cur],structs$name[cur])
    cpt <- cpt+1
}
acc$struct <- snames
remove(addr)
remove(base)
remove(page)
remove(snames)
remove(i)
remove(cur)
remove(OK)
```
```{r GenerateStructData, echo=F}
# Construct the new dataframe
structsStats <- c()
for(s in structs$name)
{
    sacc <- subset(acc, acc$struct==s)
    sacc$struct <- NULL
    sacc$addr <- NULL
    sumR <- data.frame(colSums(subset(sacc,sacc$type=="R")[-1]))
    sumW <- data.frame(colSums(subset(sacc,sacc$type=="W")[-1]))
    for(i in 1:nrow(sumR))
    {
        structsStats <- rbind(structsStats,c(s,rownames(sumR)[i],"R",sumR[i,]))
        structsStats <- rbind(structsStats,c(s,rownames(sumR)[i],"W",sumW[i,]))
    }
}
remove(sacc)
remove(structs)
remove(s)
remove(i)

structsStats <- data.frame(structsStats)
colnames(structsStats) <- c("Struct", "Thread", "Type","NbAccess")
structsStats <- transform(structsStats, NbAccess=as.numeric(as.character(NbAccess)))
# Add the sums by threads
sumR <- ddply(subset(structsStats, structsStats$Type=="R")[,-1], .(Thread), summarise, NbAccess=sum(NbAccess))
sumR$Struct <- rep("total", nrow(sumR))
sumR$Type <- rep("R", nrow(sumR))
structsStats <- rbind(structsStats,sumR)
sumW <- ddply(subset(structsStats, structsStats$Type=="W")[,-1], .(Thread), summarise, NbAccess=sum(NbAccess))
sumW$Struct <- rep("total", nrow(sumW))
sumW$Type <- rep("W", nrow(sumW))
structsStats <- rbind(structsStats,sumW)
# Remove the unused structs
for(s in unique(structsStats$Struct))
{
    df <- subset(structsStats, structsStats$Struct==s)
    df <- subset(df, df$Thread=="total")
    #Should be only two row
    if(sum(df$NbAccess)==0)
    {
        structsStats <- subset(structsStats, structsStats$Struct!=s)
        #Todo: maybe remove s from other stuff
    }
}
# Remove temporary variables
remove(sumR)
remove(sumW)
```

TABARNAC **TODO: explain the name** profides a several vizualisations of
memory traces, it aims at helping the developper finding wrong memory uses to
improve its code.

Introduction
------------

**TODO**
Classical issues

+ Remote stack access
    + First of all this is programatically bad
    + Can't be mapped efficiently by any tool
    + Use heap !!!
+ All to all sharing
    + Does not fit NUMA properties, try to make thread works on different part
    of the data
    + Replication if possible (no write, or merge in the end)
+ ??
outline of the next sections

NUMA machine
------------

**TODO: include lstopo graph here**


Data structure usages
---------------------

The following plots show the structures sizes, this information can give a
hint on the importance of the different data structures.

```{r ShowStructSize, echo=F}
if(save)
{
    ggsave(filename=paste(path,"/",name,"_structs_size.pdf", sep=""))
}
show(p)
remove(p)
```

Some of these structures might not appaear in the following plots, this means
that our tools haven't detected any access in them (it happens when we detect
structure of external libraries).

The next visualization is more interesting, it shows the number of access and
ratio Read/Write for every data structures by each threads.

```{r ByStructsPlot, echo=F, fig.height=12, fig.width=12}
df <- subset(structsStats, structsStats$Struct!="total")
p <- ggplot(df, aes(x=Struct,y=NbAccess,fill=Type))
p <- p +geom_bar(stat="identity")
p <- p + facet_wrap(~Thread, ncol=length(unique(df$Thread))/2)
p <- p + ggtitle(paste("Number of access per thread and structures for", name))
p <- p + xlab("Structure name") + ylab("Number of accesses")
if(bw)
{
    p <- p + theme_bw()
    p <- p + scale_fill_grey()
}
if(save)
{
    ggsave(filename=paste(path,"/",name,"_structs_size.pdf", sep=""))
}
show(p)
remove(p)
```


Detected problems
-----------------

**TODO: do stuff**
Have we automatically detected a classical error

+   Yes:
    + what , where , how to fix it ?
    + Look at the plot one issue might hide and other one
+   No
        If you are using that program it probably means that you have some
        perf issues, please look at the plots of the following sections

Sharing inside structures
-------------------------

For each struct the sharing by threads.
too much all to all sharing is not good for numa
The ideal thing is hierarchical sharing matching NUMA hierarchie


**TODO** Explanaitions




Distribution inside Structures
------------------------------

This visualisation show for each structure the distribution of access inside
the structure.

```{r Distribution, echo=T}
# Helper function to identify approximate curve intersections by brute force
# Function from https://gist.github.com/dsparks/4229410
intersecDf <- function(odf, str1, str2, addr1, addr2, addr3,val){
    tdf <- subset(odf, odf$Addr>=addr1)
    tdf <- subset(tdf, tdf$Addr<=addr2)
    shade <- data.frame("Addr"=tdf$Addr, "Value"=pmin(
                                                      subset(tdf$Value, tdf$Thread==str1),subset(tdf$Value, tdf$Thread==str2)))
    intersec <- data.frame("Addr"=addr3, "Value"=val)
    shade <- rbind(shade, intersec)
    shade <- shade[order(shade$Addr),]
    shade <- rbind(c(addr1,0),shade)
    shade <- rbind(shade,c(addr2,0))

    return(shade)
}

acc <- subset(acc, acc$struct!="Others")
plotname <- "Access distribution by thread for structure"
# For each structures
for(str in unique(acc$struct))
{
    # Create a df addr th num access
    sacc <- subset(acc, acc$struct==str)
    sacc$struct <- NULL
    sacc$total <- NULL
    ndf <- data.frame(cbind(rep(sacc$addr, ncol(sacc)-1),stack(sacc, select=-addr)))
    colnames(ndf) <- c("Addr", "Value","Thread")
    #   # Plot the distribution
    p <- ggplot(ndf,aes(x=Addr, y=Value) ) + geom_line()#aes(linetype=Thread))#, colour=Thread))
    #p <- p + geom_point(aes(shape=Thread))
    #p <- p + scale_colour_grey()
    p <- p + ggtitle(paste(plotname,' "', str,'"',sep="")) + xlab("Page number") + ylab("Number of Accesses")
    p <- p + theme_bw()
    if(name=="lu.S" && str=="flux")
    {
        # T0 - T1 intersect
        overlap <- c("between threads", "between NUMA nodes")
        shade <-  intersecDf(ndf,"T0","T1",1592, 1595, 1593.68,82700)
        p <-  p + geom_polygon(data=shade, alpha=.8,aes(fill=overlap[1]))
        # T1 -  T2 intersect
        shade <- intersecDf(ndf, "T1", "T2", 1596, 1600, 1598.648,82000)
        p <-  p + geom_polygon(data=shade, alpha=.8,aes(fill=overlap[2]))
        # T2 -  T3 intersect
        shade <- intersecDf(ndf,"T2","T3",1601, 1604, 1602.1,81000)
        p <-  p + geom_polygon(data=shade, alpha=.8,aes(fill=overlap[1]))
        p <- p + scale_fill_grey()
        #p <- p + scale_fill_manual(values=c("grey0", "grey60"))
        p <- p + guides(fill=guide_legend("Overlap", override.aes=list(alpha=.8)))
        p <- p + theme(legend.key.width = unit(.7, "cm"),legend.key.width = unit(.7, "cm"))
    }
    p <- p + facet_wrap(~Thread, ncol=2)
    p <- p + theme(legend.position="bottom")
    show(p)
    ggsave(paste(path, "/",name,"_", str_replace_all(paste(plotname, str), " ", "_"),".pdf", sep=""))
}
remove(ndf)
remove(p)
remove(plotname)
remove(sacc)
remove(str)
```

```{r Cleaning, echo=T}
remove(i)
remove(plots)
remove(plotnames)
remove(save)
remove(name)
remove(path)
remove(structsStats)
remove(acc)
ls()
```
