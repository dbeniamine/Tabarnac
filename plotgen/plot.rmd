Numalize plot visualization
===========================

This scripts gives a fiew visualisation of numalize trace files, it will be
replaced by a framesoc tool in a near future.

```{r Parsing, echo=T}
#Parse csv files
require(methods, quiet=T)
library(ggplot2)
library(plyr)
library(stringr)
library(data.table)
# The palette with grey:
base=paste(path,"/",name, sep="")
structs<-data.frame(read.csv2(file=paste(base,".structs.csv",sep=""),sep=',',dec='.',stringsAsFactors=FALSE))
acc<-data.frame(read.csv2(file=paste(base,".full.page.csv",sep=""),sep=',',dec='.',stringsAsFactors=FALSE))
# Information not neequired
acc$firstacc <- NULL
# Merge duplicate addresses
acct <- data.table(acc)
acct <- acct[,lapply(.SD,sum),by=c("addr","type")]
acc <- data.frame(acct)
#TODO fix total acc$total  <- rowSums(acc[,-1:-3])
stacks<-data.frame(read.csv2(file=paste(base,".stackmap.csv",sep=""),sep=',',dec='.',stringsAsFactors=FALSE))
```
```{r StructSizes, echo=T}
p <- ggplot(structs, aes(x=name,y=sz, fill=name))
p <- p + geom_bar(stat="identity")
p <- p + ggtitle(paste("Structures size for", name)) + xlab("Structure name") + ylab("Size (bytes)")
p <- p + theme_bw()
p <- p + theme(legend.position="none")
p <- p + scale_fill_grey()
show(p)
ggsave(filename=paste(path,"/",name,"_structs_size.pdf", sep=""))
remove(p)
# Simplify struct representation
structs$end <- rowSums(structs[,2:3])
structs$sz <- NULL
structs <- rbind(structs,c("Others",0,0,0))
```
```{r RetrievingPageStructMapping, echo=T}
# Retrieve page / structure mapping
snames=c()
structs <- transform(structs, start=as.numeric(as.character(start)),end=as.numeric(as.character(end)))
structs <- structs[order(structs$start),]
# Here we know that structs and acc are sorted by adresse, which ease the search
i <- 2
cur <- 2
cpt <- 1
for(page in unique(acc$addr))
{
    addr <- (2^12)*page
    OK <- F
    cur <- 1
    while(!OK && i<=nrow(structs))
    {
        show(paste(cpt,"loop current struct", i, "addr", addr))
        if(addr < structs[i,]$start)
        {
            #Addr is between two structs
            OK <- T
            show(paste(cpt,addr,"between structs nÂ°",i-1,i))
        }else
        {
            if(addr >= structs[i,]$start && addr < structs[i,]$end)
            {
                # Addr is in the next struct
                show(paste(cpt,addr,"in struct", structs[i,]$name))
                OK <- T
                cur <- i
            }else
            {
                #Addr might be in the next struct
                i <- i+1
            }
        }
    }
    snames <- c(snames,structs$name[cur],structs$name[cur])
    cpt <- cpt+1
}
acc$struct <- snames
remove(addr)
remove(base)
remove(page)
remove(snames)
remove(i)
remove(cur)
remove(OK)
```
```{r GenerateStructData, echo=T}
#show(acc)
# Construct the new dataframe
structsStats <- c()
for(s in structs$name)
{
    sacc <- subset(acc, acc$struct==s)
    show(s)
    show(sacc)
    sacc$struct <- NULL
    sacc$addr <- NULL
    sumR <- data.frame(colSums(subset(sacc,sacc$type=="R")[-1]))
    sumW <- data.frame(colSums(subset(sacc,sacc$type=="W")[-1]))
    for(i in 1:nrow(sumR))
    {
        structsStats <- rbind(structsStats,c(s,rownames(sumR)[i],sumR[i,],sumW[i,]))
    }
}
remove(sacc)
remove(structs)
remove(sumR)
remove(sumW)
remove(s)
remove(i)

structsStats <- data.frame(structsStats)
colnames(structsStats) <- c("Struct", "Thread", "NbRead", "NbWrite")
structsStats <- transform(structsStats, NbRead=as.numeric(as.character(NbRead)))
structsStats <- transform(structsStats, NbWrite=as.numeric(as.character(NbWrite)))
show(structsStats)
# Add the sums by threads
sums <- ddply(structsStats[,-1], .(Thread), summarise, NbAccess=sum(NbAccess))
sums$Struct <- rep("total", nrow(sums))
structsStats <- rbind(structsStats,sums)
# Remove temporary variables
remove(sums)
```
```{r multiplotfunction, echo=T}
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
    library(grid)

    # Make a list from the ... arguments and plotlist
    plots <- c(list(...), plotlist)

    numPlots = length(plots)

    # If layout is NULL, then use 'cols' to determine layout
    if (is.null(layout)) {
        # Make the panel
        # ncol: Number of columns of plots
        # nrow: Number of rows needed, calculated from # of cols
        layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                         ncol = cols, nrow = ceiling(numPlots/cols))
    }

    if (numPlots==1) {
        print(plots[[1]])
    } else {
        # Set up the page
        grid.newpage()
        pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

        # Make each plot, in the correct location
        for (i in 1:numPlots) {
            # Get the i,j matrix positions of the regions that contain this subplot
            matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
            print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                            layout.pos.col = matchidx$col))
        }
    }
}
```
```{r ThreadPlots, echo=T}
th <- subset(structsStats, structsStats$Thread!="total")
plots <- list()
plotnames  <- list("Access by threads", "Total access by threads", "Access by structure", "Total access by structure")
# By structure
plots[[1]] <- ggplot(subset(th, th$Struct!="total") ,aes(x=Thread,y=NbAccess,fill=Struct))
plots[[1]] <- plots[[1]] + geom_bar(position=position_dodge(.9), stat="identity")
plots[[1]] <- plots[[1]] + ggtitle(plotnames[[1]])
# Total by threads
plots[[2]] <- ggplot(subset(th, th$Struct=="total") ,aes(x=Thread,y=NbAccess,fill=Thread))
plots[[2]] <- plots[[2]] + geom_bar(position=position_dodge(.9), stat="identity")
plots[[2]] <- plots[[2]] + ggtitle(plotnames[[2]])
plots[[2]] <- plots[[2]] + theme(legend.position="none")
remove(th)
```
```{r StructsPlots, echo=T}
st <- subset(structsStats, structsStats$Struct!="total")
st <- subset(st, st$Struct!="Others")
# By structure
plots[[3]] <- ggplot(subset(st, st$Thread!="total") ,aes(x=Struct,y=NbAccess,fill=Thread))
plots[[3]] <- plots[[3]] + geom_bar(position=position_dodge(.9), stat="identity")
plots[[3]] <- plots[[3]] + ggtitle(plotnames[[3]])
# Total by structure
plots[[4]] <- ggplot(subset(st, st$Thread=="total") ,aes(x=Struct,y=NbAccess,fill=Struct))
plots[[4]] <- plots[[4]] + geom_bar(position=position_dodge(.9), stat="identity")
plots[[4]] <- plots[[4]] + ggtitle(plotnames[[4]])
plots[[4]] <- plots[[4]] + theme_bw()
plots[[4]] <- plots[[4]] + theme(legend.position="none")
plots[[4]] <- plots[[4]] + scale_fill_grey()
remove(st)
```
If there is some R warning, you should check the arguments you gave to the
script and restart.



By thread view
--------------

The first view shows the number of access done by each thread on each
structures and the total amount of access by threads.

+ Memory Imbalance
+ Thread-data affinity

```{r DisplayThread, echo=T, fig.height=7, fig.width=12}
multiplot(plotlist=plots[1:2],cols=2)
if(save=="T")
{
    ggsave(filename=paste(path,"/",name,"_summary.pdf", sep=""))
}
```

By Structure view
-----------------

This view shows the same data but from the structure point of view.

+ Important structures
+ Thread-data affinity


```{r DisplayStruct, echo=T, fig.height=7, fig.width=12}
multiplot(plotlist=plots[3:4],cols=2)
if(save=="T")
{
    ggsave(filename=paste(path,"/",name,"_summary.pdf", sep=""))
}
```

Individual plots
----------------

The same plots shown individually:

```{r IndividualPlots, echo=T}
for(i in 1:length(plots))
{
    show(plots[[i]])
    if(save=="T")
    {
        ggsave(paste(path, "/",name,"_",
                     str_replace_all(plotnames[[i]], " ", "_"),".pdf", sep=""))
    }
}
```

Distribution inside Structures
------------------------------

This visualisation show for each structure the distribution of access inside
the structure.

```{r Distribution, echo=T}
# Helper function to identify approximate curve intersections by brute force
# Function from https://gist.github.com/dsparks/4229410
intersecDf <- function(odf, str1, str2, addr1, addr2, addr3,val){
    tdf <- subset(odf, odf$Addr>=addr1)
    tdf <- subset(tdf, tdf$Addr<=addr2)
    shade <- data.frame("Addr"=tdf$Addr, "Value"=pmin(
                                                      subset(tdf$Value, tdf$Thread==str1),subset(tdf$Value, tdf$Thread==str2)))
    intersec <- data.frame("Addr"=addr3, "Value"=val)
    shade <- rbind(shade, intersec)
    shade <- shade[order(shade$Addr),]
    shade <- rbind(c(addr1,0),shade)
    shade <- rbind(shade,c(addr2,0))

    return(shade)
}

acc <- subset(acc, acc$struct!="Others")
plotname <- "Access distribution by thread for structure"
# For each structures
for(str in unique(acc$struct))
{
    # Create a df addr th num access
    sacc <- subset(acc, acc$struct==str)
    sacc$struct <- NULL
    sacc$total <- NULL
    ndf <- data.frame(cbind(rep(sacc$addr, ncol(sacc)-1),stack(sacc, select=-addr)))
    colnames(ndf) <- c("Addr", "Value","Thread")
    #   # Plot the distribution
    p <- ggplot(ndf,aes(x=Addr, y=Value) ) + geom_line()#aes(linetype=Thread))#, colour=Thread))
    #p <- p + geom_point(aes(shape=Thread))
    #p <- p + scale_colour_grey()
    p <- p + ggtitle(paste(plotname,' "', str,'"',sep="")) + xlab("Page number") + ylab("Number of Accesses")
    p <- p + theme_bw()
    if(name=="lu.S" && str=="flux")
    {
        # T0 - T1 intersect
        overlap <- c("between threads", "between NUMA nodes")
        shade <-  intersecDf(ndf,"T0","T1",1592, 1595, 1593.68,82700)
        p <-  p + geom_polygon(data=shade, alpha=.8,aes(fill=overlap[1]))
        # T1 -  T2 intersect
        shade <- intersecDf(ndf, "T1", "T2", 1596, 1600, 1598.648,82000)
        p <-  p + geom_polygon(data=shade, alpha=.8,aes(fill=overlap[2]))
        # T2 -  T3 intersect
        shade <- intersecDf(ndf,"T2","T3",1601, 1604, 1602.1,81000)
        p <-  p + geom_polygon(data=shade, alpha=.8,aes(fill=overlap[1]))
        p <- p + scale_fill_grey()
        #p <- p + scale_fill_manual(values=c("grey0", "grey60"))
        p <- p + guides(fill=guide_legend("Overlap", override.aes=list(alpha=.8)))
        p <- p + theme(legend.key.width = unit(.7, "cm"),legend.key.width = unit(.7, "cm"))
    }
    p <- p + facet_wrap(~Thread, ncol=2)
    p <- p + theme(legend.position="bottom")
    show(p)
    ggsave(paste(path, "/",name,"_", str_replace_all(paste(plotname, str), " ", "_"),".pdf", sep=""))
}
remove(ndf)
remove(p)
remove(plotname)
remove(sacc)
remove(str)
```

```{r Cleaning, echo=T}
remove(i)
remove(multiplot)
remove(plots)
remove(plotnames)
remove(save)
remove(name)
remove(path)
remove(structsStats)
remove(acc)
#ls()
```
